---
title: "Analyzing centralitty measures for a sexual network of gonorrhea transmission"
subtitle: "SOC 280 Fall 2021"
author: "J Steven Raquel"

mainfont: Times New Roman
sansfont: Times New Roman
output:
  pdf_document
geometry: "margin=1in"
fontsize: 12pt
csl: american-sociological-association.csl
header-includes:
  - \usepackage{setspace}

---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(sna)
library(igraph)
library(epimdr) # for gonnet data
library(pvclust) # for pvclust()
library(CINNA) # for pca_centralities()
library(car) # for leveneTest()
library(factoextra) # for nbclust
library(cluster) # more cluster analysis
library(netdiffuseR)
library(dendextend) # for appealing dendrograms
library(dynamicTreeCut) # for cutting the dendrogram
library(kableExtra) # nicer tables
library(knitr) # kable
library(ergm) # ERGMS
library(coda)
library(statnet)
library(latticeExtra)
library(GGally) # ggnet2 
library(foreign)
library(ergm.userterms)
library(Matrix)
source(here::here("functions.R"))
```


\doublespacing

# Abstract

# Introduction

Contact tracing for sexually transmitted diseases (STDs) such as gonorrhea, chlamydia, syphilis etc. is a persistent epidemiological problem, as it depends on individuals getting routinely tested as well as informing their sexual partners of their positive diagnosis should they receive one. Compounding this with the fact that many of these positive cases can be symptomless but still contagious creates a serious issue. Gonorrhea in particular is a disease that can be asymptomatic in both men and women who have it, that can go so far as causing infertility or lead to a life-threatening condition.

This dataset, constructed in the form of an adjacency matrix, contains 89 nodes, one of which is the "event" of attending a bar (i.e. when a node has a tie with this bar node, it means they attend the bar). Two of these nodes (denoted by `x` and `x2`) are missing information about their gender which is otherwise indicated by an `m` or `f` in the label of the respective node, followed by a number with which to differentiate them.

The network is directed, and the criteria for some node $i$ to have a tie with some other node $j$ must be that that $i$th node named node $j$ as a prior sexual partner. 

The data was collected from a series of adjacent aboriginal communities located in the province of Alberta, Canada, where public health officials took note of a local gonorrhea outbreak and confirmed that attendance at a local bar in one such community was associated with infection (De 2003).

# Background

## Data Collection 

The sociometric approach for enumerating a sexual network entails an iterative process in which the subject names past sexual partners, who are them traced and interviewed to identify whether they are linked and also to identify other contacts in the network (Doherty 2005). Conversely, the egocentric approach bases the network entirely on the information volunteered by the original subject. 

There are a number of shortcomings that are inherent to mapping out a sexual network, the first being that the design suffers from incomplete-network bias when partners cannot be traced or recruited for a variety of reasons (Doherty 2005). For example, the contact tracing of sexual partners is relegated to those who have a positive test result, and since such individuals may have markedly different positions within a network, tracing a network consisting solely of STI-positive partners has an inherent bias.

For example, consider that the prevalence of STI infection has a high negative correlation with condom usage i.e. using condoms infrequently, or not at all, comes with a higher risk of contracting an STI. If we assume individuals who engage in this kind of risky behavior on a regular basis are more likely to test positive for an STI, then the mapping of our sexual network may predominantly include only those individuals who partake in this behavior to some degree, and their partners with whom they had safe sex with (or simply did not transmit an STI to) will go unrecorded.

There are some behavioral considerations taken into account when considering this data, as is inherent with studies in which data is based on information nominated directly from the subjects. In a sexual network such as this the information regarding past sexual partners is volunteered on the part of the individual who represents the node in the graph, and as such, it's subject to an individual possibly withholding information, or simply not having the information at all. For example, an individual may be reluctant to disclose the identity of a sexual partner if they are in a monogamous relationship and to disclose this event would mean owning up to infidelity, or perhaps if the sex was in exchange for money i.e. sex work. It could also be that the sex occurred in an anonymous context and they simply do not have the information on the individual.

There is a social stigma attached to promiscuity (having a high number of sexual partners), as well as living with an STI, so it's important to note that the data may be skewed by dishonesty on the part of the individuals comprising the dataset. For example, a person who receives a positive test result for a sexually transmitted disease may refrain from naming _all_ of their recent sexual partners, either to avoid having to communicate the uncomfortable truth of either having contracted or transmitted a disease, or to avoid judgment for divulging what may be perceived as a high number of sexual partners. Societal attitudes towards sex and sexual health both in a Western context and also in an indigenous/Aboriginal context can and should be kept in mind when drawing conclusions from this data.

Some of these biases could be mitigated if we had all of the complete information on infection/non-infection status and were able to recruit all members of a sexual network, but this is impractical, improbable, or even illegal in some areas. These biases are inherent to these types of models but these studies still are important in anticipating and modeling the spread of STIs due to the highly social component of transmission, compared to for example, the spread of influenza.

Wasserman and Faust (1994) define "cutpoints" and "bridges" as nodes and ties respectively that cause the graph in which they are contained to have less components if they were to be taken out from the graph. In other words, they are the nodes or ties that connect what would be otherwise unconnected sub-graphs. These are crucial in sexual network analysis because these nodes and ties are the difference between whether a certain network may propagate an STI outbreak or not. 

# Methods

# Results

# Discussion

# Conclusions

\singlespacing

```{r data-prep, echo = F}
# library(epimdr) is loaded
data(gonnet)
# data is loaded as 'gonnet'
nodes <- rownames(gonnet)
# indices where "x" and "x2 are
xs <- which(nodes %in% c("x", "x2"))
# drop rows/columns with these numbers
gonnet <- gonnet[-xs, -xs]
# symmetrized graph (undirected)
gonnet <- symmetrize(gonnet, rule = "weak")
nodes <- nodes[-xs]
rownames(gonnet) <- nodes
colnames(gonnet) <- nodes


# creating data.frame with traits
gonnet_df <- data.frame(nodes) %>%
  dplyr::mutate(gender = ifelse(grepl("m", nodes), yes = "M", no = NA)) %>%
  dplyr::mutate(gender = ifelse(grepl("f", nodes), yes = "F", no = gender)) %>%
  dplyr::mutate(gender_lty = ifelse(gender == "M", yes = 4, no = 3)) %>%
  dplyr::mutate(gender_lty = ifelse(gender == "F", yes = 3, no = gender_lty)) %>%
  dplyr::mutate(gender_lty = ifelse(gender %in% c("M", "F"), yes = gender_lty, no = 50)) %>%
  dplyr::mutate(attended_bar = (gonnet["b",] == 1)) %>%
  dplyr::mutate(col = ifelse(attended_bar == T, "tomato1", "grey"))


gonnet_df$col[!(gonnet_df$gender %in% c("M", "F"))] <- "blue"
gonnet_df$col[gonnet_df$nodes == "b"] <- "tomato1"
gonnet_df$gender[gonnet_df$nodes == "b"] <- "NA"

# creating igraph object
gonnet_ig <- graph_from_adjacency_matrix(gonnet)

(pc <- proper_centralities(gonnet_ig)) %>% 
  capture.output() %>%
  invisible()

centralities <- calculate_centralities(gonnet_ig, 
                       include = pc[c(1, 4, 11, 16, 27, 
                                      45, 8, 18, 31, 43, 3, 19)])

# we care about 
# closeness centrality, katz centrality, eigenvector centrality, avg distance, degree centrality, and information centrality

cen <- data.frame(closeness = centralities$`Closeness Centrality (Freeman)`,
                  katz = centralities$`Katz Centrality (Katz Status Index)`,
                  eigenvector = centralities$`eigenvector centralities`,
                  avg_distance = centralities$`Average Distance`,
                  degree = centralities$`Degree Centrality`,
                  information = centralities$`Information Centrality`)

gonnet_df2 <- cbind(gonnet_df, cen)

# dropping bar object from this network
gonnet_nobar <- gonnet[-1,]
gonnet_nobar <- gonnet_nobar[,-1]

# creating network object
gonnet_net_nobar <- network(gonnet_nobar, directed = F)

# adding bar attendance on graphs
network::set.vertex.attribute(gonnet_net_nobar, 'bar', 
                             gonnet_df2$attended_bar[-1])
# adding gender to the graph
network::set.vertex.attribute(gonnet_net_nobar, 'gender', gonnet_df2$gender[-1])
network::set.vertex.attribute(gonnet_net_nobar, 'degree', cen$degree[-1])
```

```{r network-objects, echo = F}

# creating a network object of the two-mode network with the bar
gonnet_net_bar <- network(gonnet, directed = F)

# adding gender to the graph
network::set.vertex.attribute(gonnet_net_bar, 'gender', gonnet_df2$gender)
network::set.vertex.attribute(gonnet_net_bar, 'degree', cen$degree)

# adding a linetype attribute so that the edges to the bar are dashed lines
edgelist <- as.matrix(gonnet_net_bar, matrix.type="edgelist")
network::set.edge.attribute(gonnet_net_bar, "lty", 
                            ifelse(edgelist[,2] == 1, 2, 1))

```


```{r sociogram-ggnet2-bar, echo = F, fig.cap = "The two-mode network with bar as a node."}
set.seed(62)
ggnet2(gonnet_net_bar,
       color = "gender", 
       palette = c("M" = "lightblue", "F" = "salmon", "NA" = "grey"),
       mode = "fruchtermanreingold",
       label = F,
       edge.lty = "lty", 
       size = 5)

```


```{r sociogram-ggnet2-nobar, echo = F, fig.cap = "The one-mode network without the bar as a node."}
set.seed(62)
# GGally is loaded
ggnet2(gonnet_net_nobar, 
       color = "gender", palette = c("M" = "lightblue", "F" = "salmon"), 
       shape = "bar", 
       mode = "fruchtermanreingold", 
       label = F,
       size = 5)

```

\doublespacing

Looking at this initial sociogram, where the bar node is firmly in the center, we see that it has outgoing connections to 17 nodes, which themselves have connections to at least one other node in the rest of the network. 

The majority of ties are between individuals of the opposite sex, e.g. male-to-female or female-to-male, but there are a minority of instances where individuals have a tie to individuals of the same sex, e.g. m112 has ties with both m106 and m107, who both in turn have ties to at least one female node. 

The node m010 is also unique in that it happens to have outgoing ties to one female node (f024) and one male node (m018), the latter of which in turn has a tie with a female node (f023). The idea of men who have sex with men (MSM) or women who have sex with women (WSW) acting as bridging nodes between otherwise disparate sexual networks was something considered in the exploratory analysis but there just wasn't enough data to delve deeper into this subject.

The first approach in the analysis was to look at the _centrality measures_ of each of the nodes.

## Centrality Measures

\singlespacing


```{r centralities_more, echo = F}


# plot of different centralities' contributions via PCA
pca_centralities(centralities)

```

\doublespacing

According to Borgatti and Everett (2006), _centrality_ is a summary index of a node's position in a graph, based on sums or averages of one of several things: 1) the number of edges the node has, 2) the length of the paths that end up at the node, or 3) the proportion of paths that contain the node inside of it (not as an endpoint).

Different measures of centrality depend on functions of one of these aspects and communicate different things about a node, depending on the algorithm for the centrality measure. Among the centrality measures used in this analysis were that of _degree centrality_, _eigenvector centrality_, _load centrality_, and _information centrality_. 

### Degree Centrality

Degree centrality can be measured in multiple ways; the first is _indegree_ which is a count of the number of incoming ties that a node has. The second is _degree_ which conversely is the count of the number of outgoing ties that a node has. 

The vast majority of nodes in the directed network have an indegree of 1, i.e. only one individual nominated that person as a sexual partner when interviewed. The degree was _at least_ 1 for most nodes in the network, but could be zero for nodes on the very outside of the network who did not name any sexual partners. 

The overall degree of a node can be taken as the total amount of ties a node has, either incoming or outgoing, but in the case of an undirected graph, these are one and the same.

#### degree Centrality

\singlespacing



```{r figure-bar-degree, fig.cap = "Distribution of degree, by bar attendance.", echo=FALSE}
# boxplot of degree by bar attendance
gonnet_df2 %>%
  filter(!is.na(gender)) %>%
  ggplot(aes(x = attended_bar, y = degree)) +
  geom_boxplot() + 
  ggtitle("Boxplot of Degree, by Bar Attendance") +
  theme_bw()
```

```{r figure-gender-degree, fig.cap = "Distribution of degree, by gender.", echo=FALSE}
# boxplot of degree by gender
gonnet_df2 %>%
  filter(!(gender == "NA")) %>%
  ggplot(aes(x = gender, y = degree)) +
  geom_boxplot() + 
  ggtitle("Boxplot of Degree, by Gender") +
  theme_bw()
```

```{r table-male-female-degree, fig.cap = "Average degree, by gender.", echo = F}
# average degree overall
mean_overall_degree <- gonnet_df2$degree %>% mean()

gonnet_df2 %>% 
  filter(!(gender == "NA")) %>%
  group_by(gender) %>%
  summarize(average_degree = mean(degree) %>% round(3)) %>% 
  kbl(col.names = c("Gender", "Mean Degree")) %>%
  kable_classic()

```

```{r table-bar-degree, fig.cap = "Average degree, by bar attendance.", echo = F}
gonnet_df2 %>% 
  filter(!(gender == "NA")) %>%
  group_by(attended_bar) %>%
  summarize(average_degree = mean(degree) %>% round(3)) %>% 
  kbl(col.names = c("Attended Bar", "Mean Degree")) %>%
  kable_classic()


```

\doublespacing

The analysis gave that the overall average degree for the directed graph is approximately 1, implying that on average individuals named one sexual partner. It's important to note that many outer edges have an degree of 0, which skews down the mean calculation somewhat. 

The implication of this observation is two-fold. For one, rather than most individuals in the network having many sexual partners, the implication of how degree is distributed in this network is that most individuals have as few as one, but there is a minority of individuals (of both genders) who named more. 

### Eigenvector Centrality

Eigenvector centrality is calculated both as a function of a node's degree but also as a function of the degree of the nodes it is connected to. In other words, a node with a high eigenvector centrality is well-connected to nodes that are themselves well-connected. 

### Load Centrality

### Information Centrality
\singlespacing

```{r gplot-degree, echo = F, fig.cap = "Gonorrhea network, sized by degree."}
# normalizing the degree of bar because of course it has a high degree
degree_m <- cen$degree + 1
degree_m[1] <- 3

set.seed(10)

# plotting based on degree
ggnet2(gonnet_net_nobar, 
       color = "gender", palette = c("M" = "lightblue", "F" = "salmon"), 
       shape = "bar", 
       mode = "fruchtermanreingold", 
       size = "degree",
       label = F)
```


## Principal Component Analysis

```{r gplot- centralities, include = F}
# extracting the centralities that were important based on the PCA
centrality_eigen <- centralities$`eigenvector centralities`
centrality_load <- centralities$`Load Centrality`
centrality_degree <- centralities$`Degree Centrality`
centrality_geodesic <- centralities$`Geodesic K-Path Centrality`
centrality_shortest <- centralities$`Shortest-Paths Betweenness Centrality`
centrality_info <- centralities$`Information Centrality`
```

```{r gplot-size-eigenvector-centrality, eval = F, fig.cap = "Gonorrhea network, sized by eigenvector centrality."}
set.seed(10)

centrality_eigen[1] <- 0.01
gplot(gonnet, vertex.col = gonnet_df$col,
      vertex.sides = gonnet_df$gender_lty,
      vertex.cex = scale(centrality_eigen) + 2,
      # displaylabels = T, label.cex = 0.6, label.pos = 2,
      boxed.labels = F, pad = 2,
      coord = org_coord, usearrows = F)
```

```{r find-best-cluster-number, echo = F, eval = F}
# library(factoextra) is loaded
fviz_nbclust(gonnet, kmeans, method = "wss", k.max = 30)

# library(cluster) is loaded
gap_stat <- clusGap(gonnet, FUN = kmeans, nstart = 25, K.max = 30, B = 50)
fviz_gap_stat(gap_stat)
```

```{r kmeans-clustering, eval = F}
km <- kmeans(gonnet, centers = 21, nstart = 25)

# fviz_cluster(km, data = gonnet_nob)

# library(netdiffuseR) is loaded
gonnet_edgelist <- adjmat_to_edgelist(gonnet, undirected = F)

# cluster_membership
km_cluster_mem <- km$cluster %>% as.data.frame() %>%
  tibble::rownames_to_column() %>%
  rename(node = 'rowname', cluster = '.')

```

```{r hierarchical-clustering, eval = F, echo = F}
set.seed(10)
par(mfrow = c(1,1))
clust <- hclust(dist(gonnet), method = "average")
clust_dend <- clust %>% as.dendrogram()
# clust <- equiv.clust(gonnet)

bm_complete <- blockmodel(gonnet,
                          ec = clust, k = 15)

bmR_complete <- reorder_blockmodel(bm_complete)
# overall network density, which we will use for alpha
alpha <- bmR_complete$block.model %>% mean(na.rm = T)
paste0("The mean overall network density is ", round(alpha, 3), ".")

density_matrix <- bmR_complete$block.model
# plotting blockmodel 
gplot(density_matrix > alpha,
      diag = T,
      vertex.cex = 1.5,
      label = unique(bmR_complete$block.membership),
      # boxed.labels=F,
      vertex.col="grey",
      pad = 1.25)
title("Block sociogram")
```


```{r agnes-hclust, echo = F, eval = F}
set.seed(10)
par(mfrow = c(1,1))
#define linkage methods
hclust_methods <- c("average", "single", "complete", "ward")
names(hclust_methods) <- hclust_methods
#function to compute agglomerative coefficient
ac <- function(data, method) {
  agnes(data, method)$ac
}

# cluster is loaded

#calculate agglomerative coefficient for each clustering linkage method
ac_list <- list()
for (i in 1:4) {
  ac_list[[i]] <- agnes(gonnet, diss = FALSE, metric = "euclidean",
                        method = hclust_methods[i])  
  
  print(ac_list[[i]]$ac)
}
# maximum agglomerative coefficient is from the single linkage algorithm

# hclust using single and agnes
# clust <- agnes(gonnet, "single", diss = F)

#pltree(clust, cex = 0.6, hang = -1)
```


```{r p-value-hierarchical-clustering, cache = T, eval = F}
fit <- 
  pvclust(gonnet, 
  method.hclust = "single",
  method.dist = "euclidean",
  iseed = 10, # to get same results
  parallel = T, # to use all but one CPU thread
  nboot = 1000) 
```

```{r dynamic-tree-cut, eval = F}
fit_hclust <- fit$hclust
fit_hclust %>% cutreeDynamicTree(deepSplit = F)
```

```{r plot-dendrogram, echo = F, eval = F}
par(mfrow = c(1,1))
plot(fit, hang = -1, cex = 0.5)
pvrect(fit, alpha = 0.95)
```



```{r blockmodel, echo = F, eval = F}
set.seed(10)
# if pchisq > 0.05, cluster is significant
pp <- pvpick(fit)
# number of significant clusters
ideal_k <- pp$clusters %>% length()

# note that these are just the "child" clusters and I want to include their parents

# blockmodel using k = 58 and cutting trees at 0.5
bm_complete <- blockmodel(gonnet,
                          ec = fit$hclust,
                          k = ideal_k + 9, mode = "digraph")

bmR_complete <- reorder_blockmodel(bm_complete)
# overall network density, which we will use for alpha
alpha <- bmR_complete$block.model %>% mean(na.rm = T)
paste0("The mean overall network density is ", round(alpha, 3), ".")

density_matrix <- bmR_complete$block.model

par(mfrow = c(1,2))
# original plot, again
gplot(gonnet, vertex.col = gonnet_df$col,
      vertex.sides = gonnet_df$gender_lty,
      # displaylabels = T, label.cex = 0.6, label.pos = 2,
      boxed.labels = F, pad = 2, 
      vertex.cex = 1.25)
# legend for gender
legend("topleft",
       legend = c("yes", "no"),
       col = c("tomato1", "grey"),
       fill = F, border = "white", pch = 19,
       title = "Bar Attendance", bty = "n")
legend("topright",
       legend = c("m", "f"),
       col = c("black"),
       fill = F, border = "white", pch = c(0, 2),
       title = "Gender", bty = "n")
# legend for bar attendance
title("Network of gonorrhea transfer")

# plotting blockmodel 
gplot(density_matrix > alpha,
      diag = T,
      vertex.cex = 1.5,
      # label = unique(bmR_complete$block.membership),
      # boxed.labels=F,
      vertex.col="grey",
      pad = 1.25, 
      # coord = org_coord
      )
title("Block sociogram")

```



```{r plotting-fast-greedy-community, echo = F}
set.seed(10)
par(mfrow = c(1,2))
# original plot, again
org_coord <- gplot(gonnet, vertex.col = gonnet_df$col,
      vertex.sides = gonnet_df$gender_lty,
      # displaylabels = T, label.cex = 0.6, label.pos = 2,
      boxed.labels = F, pad = 2, 
      vertex.cex = 1.25,
      usearrows = F)
# legend for gender
legend("topleft",
       legend = c("yes", "no"),
       col = c("tomato1", "grey"),
       fill = F, border = "white", pch = 19,
       title = "Bar Attendance", bty = "n")
legend("topright",
       legend = c("m", "f"),
       col = c("black"),
       fill = F, border = "white", pch = c(0, 2),
       title = "Gender", bty = "n")
title("Original graph")
# adding in shape arguments for igraph to correspond to original sna gplot


# fast and greedy community detection
plot_fastgreedy_cd(gonnet, layout = org_coord, 
                   legend = F, vertex.size = 6)
title("Graph, shaded by fast-greedy community")
# labeling only the original bar patrons
```

\doublespacing


## Exponential Random Graph Model (ERGM)

Exponential random graph models (ERGMs) are a family of statistical models for social networks that permit inference about prominent patterns in the data, given the presence of other network structures (Carrington and Scott, 2011). For a given set of $n$ actors, an ERGM models an observed network $x$ by assigning a probability to every network of $n$ actors, and the form of such a model is as follows

$$\Pr(X = x) = \frac{1}{k} \exp\{\sum_A \eta_Ag_A(x) \}$$
where the sum is over all configuration types $A$; 

* $\eta_A$ is a parameter correpsonding to configuration type $A$; 
* $g_A(x)$ is the _network statistic_ for $A$ and is the number of configurations $A$ observed in $x$
* $k$ normalizes this to be a proper probability distribution.

This equation implies that there is a probability distribution of all possible networks with $n$ nodes, with each such network having their own distinct probability.

\singlespacing

```{r ergm-data, include = F}
gonnet.degreedist <- table(sna::degree(gonnet))
gonnet.degreedist

```

```{r get-aic, echo = F}
# get aic function
get_from_summary <- function(ergm_model, object) {
    
  sum <- summary(ergm_model)  
  
  if (object == "aic") {
    y <- sum$aic[1]
  }
  else if (object == "formula") {
    y <- sum$formula
  }
  
  return(y)
}

```

```{r ergm, echo = F, cache = T}
set.seed(55)

# nodematch , uniform homophily, differential hom

# library(ergm) is loaded
# simple model
ergm_model1 <- ergm(gonnet_net_nobar ~ edges)
summary(ergm_model1)
# homophily
# do bar patrons hook up with one another?
ergm_model2 <- ergm(gonnet_net_nobar ~ edges + nodematch("bar"))
summary(ergm_model2)
# goodness of fit test
# closer the p-value is to 1 the better, both are very close to 1
model2_gof <- gof(ergm_model2, GOF = ~model)
model2_gof
plot(model2_gof)

# likelihood ratio test to compare model1 to model 2
# H0: the simpler model is preferred
anova(ergm_model1, ergm_model2)

# using symmetric model
ergm_model3 <- ergm(gonnet_net_nobar ~ edges + degree(d = c(2:3)))
summary(ergm_model3)
# diagnostics
mcmc.diagnostics(ergm_model3)
model3_gof <- gof(ergm_model3, GOF = ~model)
model3_gof
plot(model3_gof)

# heterophily of gender
# i.e. do males connect to females and vice versa
ergm_model4 <- ergm(gonnet_net_nobar ~ edges + nodemix("gender"))
summary(ergm_model4)
model4_gof <- gof(ergm_model4, GOF = ~model)
model4_gof
plot(model4_gof)

# nodecov 
ergm_model5 <- ergm(gonnet_net_nobar ~ edges + nodecov("bar"))
summary(ergm_model5)
model5_gof <- gof(ergm_model5, GOD = ~model)
model5_gof
plot(model5_gof)

# nodefactor
ergm_model6 <- ergm(gonnet_net_nobar ~ edges + nodefactor("bar"))
summary(ergm_model6)
model6_gof <- gof(ergm_model6, GOF = ~model)
model6_gof
plot(model6_gof)

# heterophily on bar attendance
ergm_model8 <- ergm(gonnet_net_nobar ~ edges + nodemix("bar"))
summary(ergm_model8)
model8_gof <- gof(ergm_model8, GOF = ~model)
model8_gof
plot(model8_gof)
```


```{r ergm-model-fitting, echo = F, cache = T}
set.seed(55)
ergm_model7 <- ergm(gonnet_net_nobar ~ 
                      edges + nodemix("gender") + degree(d = c(2:3)) + nodematch("bar"))
summary(ergm_model7)
model7_gof <- gof(ergm_model7, GOF = ~model)
model7_gof
plot(model7_gof)


mcmc.diagnostics(ergm_model7)
```


```{r table-model-comparison, echo = F}
model_list <- list(ergm_model1, ergm_model2, ergm_model3,
                   ergm_model4, ergm_model5, ergm_model6)

aics <- sapply(model_list, FUN = get_from_summary, object = "aic")
formulas <- sapply(model_list, FUN = get_from_summary, object = "formula")

df <- matrix(data = c(formulas, aics),
              nrow = length(aics),
              ncol = 2) %>% 
  as.data.frame() %>%
  rename(formula = V1, aic = V2)

df %>% 
  kbl(caption = "Table of Akaike Information Criteria for each ERGM model") %>% 
  kable_classic()  

```

\newpage

\doublespacing

# References

De P, Singh AE, Wong T, et al. 2004. "Sexual network analysis of a gonorrhea     outbreak." *Sexually Transmitted Infections* 80:280-285.

Carrington, P. and Scott, J., 2011. *The SAGE handbook of social network          analysis. 1st ed.* Los Angeles [etc.]: SAGE Publications, pp.484-500.

  Irene A. Doherty, Nancy S. Padian, Cameron Marlow, Sevgi O. Aral, Determinants and Consequences of Sexual Networks as They Affect the Spread of Sexually Transmitted Infections, The Journal of Infectious Diseases, Volume 191, Issue Supplement_1, February 2005, Pages S42â€“S54, https://doi.org/10.1086/425277

Wasserman, S. and Faust, K., 1994. Social network analysis: methods and applications. Cambridge: Cambridge University Press.

\newpage

# Appendix

\singlespacing

```{r get-labels, echo = F, include = F}
labs <- knitr::all_labels()
#```{r ref.label = labs, eval = F, include = F}
#```

```

